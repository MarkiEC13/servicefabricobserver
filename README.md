---2services: service-fabric3platforms: dotnet4author: paolosalvatori5---6# Service Fabric Observer Sample #7This project contains a framework that provides an implementation of the Observer design pattern for Service Fabric stateful services and actors.89# Introduction #10The Service Fabric Observer Framework provides the base classes and services to implement the Observer design pattern in a Service Fabric application.1112<center>![Architecture](https://raw.githubusercontent.com/azure-cat-emea/servicefabricobserver/master/Images/Architecture.png)</center>1314The design pattern shown in the above diagram represents a hybrid between Observable-Observer and Observer design patterns: in fact, in this framework observables and observers communicate with each other directly as in the Observer pattern, but observers typically discover topic-specific observables via a stateful registry service. In addition, they can specify filter expressions to receive only a subset of messages sent by observables. The registry service exposes the **IRegistryService** interface that can used by observable services and actors to register and unregister as an observable for a given topic. Observers can invoke the **QueryObservables** method to discover observables for a given topic. The observer can register with one or multiple observables by invoking the **RegisterObserver** method on the **IObservable** interface exposed by an observable. Likewise, when a service partition or actor is removed from the system, or whenever it decides to no longer receive messages from a given observable, it can invoke the **UnregisterObserver** on the **IObservable** interface exposed by the observable service partition or actor. Each observer maintains a list of the observable to which is registered. Likewise, an observable maintains a list of its observers, and it sends a copy of the message to each of them by invoking the **Notify** method on their **ISubscribe** interface. The observable can directly send the message to each of the observers, or can divide observers by cluster node, and use one the observers for each node as a proxy. In this case, along with the message, the observer will receive a list of observers located on the same node to which forward the message. When the observable is unable to send a message to the proxy observer, it will write the message to the messagebox of the observer by invoking the **WriteMessages** method exposed by the **MessageBoxService** and will promote another observer from the same list as proxy for the node. More in general, the framework retries every operation a configurable amount of time and uses a configurable backoff delay  between retries. In particular, when an observable sends messages to its observers, the observable tries to send the message to each observer directly or via a proxy and in case the maximum number of retries expires, he message is saved to the messagebox of the observer, so that, when it comes back online, it can retrieve along with the other messages by invoking the ReadMessages method exposed by the **MessageBoxService**. Before shutting down, an observable invokes the **UnregisterObservable** method on the **ISubscribe** interface of its observers to notify them that it is leaving. Likewise, the observable invokes the **UnregisterObservable** on the **IRegistry** interface exposed by the registry service, to notify it that itâ€™s leaving. The registry service proceed to remove the observable from the list of observables for a certain topic. The registry service uses a **ReliableDictionary** to store observables: the item key is the topic, while the value is a list of observables for that topic. Observables are required to periodically send a heartbeat message to the registry service.1516## Demo ##17The following diagram shows the architecture design of the demo:1819<center>![Demo](https://raw.githubusercontent.com/azure-cat-emea/servicefabricobserver/master/Images/Demo.png)</center>2021As you can see, you can use a client application to invoke three different tests, directly via ActorProxy/ServiceProxy when testing the application on the local cluster, or via gateway service that is implemented as a stateless reliable service. The gateway service exposes a REST interface implemented by six ASP.NET Web API REST services (**ApiController**). These services, allows to interact with:2223
